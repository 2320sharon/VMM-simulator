// CSC139HW2.cpp : This file contains the 'main' function. Program execution begins and ends there.
//Sharon Fitzpatrick
// VMM Simulator

#include<cstdio>  
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<stack>
#include <vector>
#include<string>
#include<iostream>
#include <fstream>
#include <sstream> 

using namespace std;

// const global variables
const int REPLACEMENT_CYCLES = 10;					    //cost of replacing a page   
const int PAGE_SIZE = 4096;	
const int MAX_PAGE_ENTRIES = 1024;						//4096 / 4 
const int PAGE_DIR_ACCESS =1;							// access through PD cost 1 cycle each
const int SWAP_COST =5000;

//global variables
int MEM_CYCLES=0;
int MEM_ACCESS=0;
int NUMBER_SWAPINS=0;
int NUMBER_SWAPOUTS=0;
int TOTAL_PAGES_MALLOC=0;
int TRIPLES=0;
int NUMBER_PAGE_FRAMES=0;
int NUM_PAGES_PAGETABLE=0;
int LAST_WORKING_SET=0;
int MAX_WORKING_SET=0;
int MAX_PHYSICAL_PAGES=0;
int MEM_CYCLES_NO_VMM=0;

int get_page_offset(int address)
{
	int PAGE_MASK = 4095;
	return (address & PAGE_MASK); // get second set of leftmost 10 bits
}

int get_pagetable_index(int address)
{
	int PT_MASK = 4190208;
	return (address & PT_MASK) >> 12; // get second set of leftmost 10 bits
}

int get_pagedir_index(int address)
{
	return (address >> 22); //get leftmost 10 bits by geting rid of 22 rightmost bits we dont care about
}


int get_address(int pt_index, int pd_index)
{
	string string_pt = to_string(pt_index);
	string string_pd = to_string(pd_index);
	string addr_string = string_pt + string_pd;
	return(stoi(addr_string));
}

class STATS {
public:

	void write_to_output()
	{

		MEM_CYCLES_NO_VMM = MEM_ACCESS * REPLACEMENT_CYCLES;

		ofstream myfile;
		myfile.open("output.txt");
		myfile << "***Paging Activity Statistics * **.\n";
		myfile << "number of memory accesses ="<< MEM_ACCESS<<" .\n";
		myfile << "number of triples(1 + access) = " << TRIPLES << " .\n";
		myfile << "number of swap ins(faults) = " << NUMBER_SWAPINS << " .\n";
		myfile << "number of swap outs = " << NUMBER_SWAPOUTS << " .\n";
		myfile << "total number of pages malloced = " << TOTAL_PAGES_MALLOC << " .\n";
		myfile << "number of pages for Page Tables = " << NUM_PAGES_PAGETABLE << " .\n";
		myfile << "number of page frames for user = " << NUMBER_PAGE_FRAMES << " .\n";
		myfile << "total memory cycles = " << MEM_CYCLES << " .\n";
		myfile << "cycles w / o Vmm = " << MEM_CYCLES_NO_VMM << " .\n";
		myfile << "cycles per swap_in = 5000.\n";
		myfile << "cycles per swap_out = 5000.\n";
		myfile << "last working set size = " << LAST_WORKING_SET << " .\n";
		myfile << "max working set size ever = " << MAX_WORKING_SET << " .\n";
		myfile << "max physical pages = " << MAX_PHYSICAL_PAGES << " .\n";
		myfile << "page size = 4096.\n";
		myfile << "replacement algorithm = random.\n";
		myfile.close();
	}

};
//function to read input file


struct PageTable_entry {
	unsigned int address=0;	//address of page (address given shifted by 12 bits to the right)
	bool Dirtybit=0;		//set if page frame is modified
	bool Presentbit=0;		//set if page frame is in memory
	bool On_Disk = 0;		//set if page frame is on disk
	int index_of_frame = -1;	//index of page frame it points to -1 means it doesnt exist or on the disk
};

struct PageTable
{
	 PageTable_entry pt_entries[1024];//a page table can hold 1024 total enties (4096 total bytes/4 bytes per entry)
	 bool exists = 0;
};

class DiskBlock {
private:
	typedef struct Disk {
		unsigned int page_address;			//address of page
		Disk* next_disk;
	}*disk_ptr;

	disk_ptr head;
	disk_ptr temp;
	disk_ptr curr;

public:
	void Add_Disk(unsigned int addr)
	{
		disk_ptr newdisk = new Disk;
		newdisk->next_disk = NULL;
		newdisk->page_address = addr;

		if (head != NULL)
		{
			curr = head;
			while (curr->next_disk != NULL)
				curr = curr->next_disk;

			curr->next_disk = newdisk;//new page will be  at the end of list of disks
		}
		else//means we have an empty disk
		{
			head = newdisk;
		}
	}
	bool Remove_disk(unsigned int addr)
	{
		disk_ptr delete_disk = NULL;
		temp = head;
		curr = head;
		while ((curr != NULL) && (curr->page_address != addr))
		{
			temp = curr;
			curr = curr->next_disk;
		}
		if (curr == NULL)
			cout << endl << "page with address: " << addr << "was not on the disk";
		else
		{
			delete_disk = curr;
			curr = curr->next_disk;
			temp->next_disk = curr;
			delete delete_disk;
		}
	}
	void print_disk()
	{
		curr = head;
		cout << "\n*****Printing contents of disk*****\n";
		while (curr != NULL)
		{
			cout << curr->page_address << endl;
			curr = curr->next_disk;
		}
	}
	~DiskBlock() {
		curr = head;
		temp = head;
		while (curr)
		{
			curr = curr->next_disk;//move to text spot
			free(temp);
			temp = curr;
		}
	}
};

class Main_Memory {
	int num_free_frame_left;
	//dynamically allocated page frames based on page frames given by user
	PageTable_entry** page_frames;
	DiskBlock disk;
public:
	Main_Memory()
	{
		page_frames = new PageTable_entry*[NUMBER_PAGE_FRAMES];
		num_free_frame_left = NUMBER_PAGE_FRAMES;
	}

	~Main_Memory()
	{
		delete[] page_frames;
		num_free_frame_left = 0;
		cout << "\nDeleting the page frames\n";
	}

	void allocate_free_frames( PageTable_entry* pt_entry ){
		int index_frame;
		if (!any_free_frame())//means no free frames
		{
			index_frame = 0;
			Swap_Out(page_frames, index_frame,disk);			//swap out will copy the page frame's page address to disk
			if ((*pt_entry).On_Disk == true)
			{
				Swap_In(pt_entry,disk);							// swap in removes the page from the disk
			}
			page_frames[index_frame] = pt_entry;				//replace the first page frame with the page
		}
		else
		{
			++ LAST_WORKING_SET;
			if (MAX_PHYSICAL_PAGES < NUMBER_PAGE_FRAMES) ++MAX_PHYSICAL_PAGES;
			if (MAX_WORKING_SET < MAX_PHYSICAL_PAGES)  ++MAX_WORKING_SET;
			//fill in pages from last spot to first spot
			index_frame = num_free_frame_left - 1;
			take_free_frame();	//remove a free frame
			page_frames[index_frame] = pt_entry;
			pt_entry->Presentbit = true;				//set present bit to true to indicate its in memory

		}
		
	}

	void delete_freeframes()
	{
		delete[] page_frames;
	}
	void take_free_frame() { --num_free_frame_left; }
	bool any_free_frame() { return ((num_free_frame_left < 0)? false : true ) ; }


	//take a page away from the page_frames 
	void Swap_Out(PageTable_entry** pt, int pageframeindex, DiskBlock out_disk)
	{
		//take the first page out of the page frame array for random replacement
		MEM_CYCLES += SWAP_COST;
		(*(pt+ pageframeindex))->Presentbit = 0;							//indicates no longer on a frame
		(*(pt + pageframeindex))->Dirtybit = 0;								// page to be stored on disk so the modify bit is cleared
		out_disk.Add_Disk((*pt + pageframeindex)->address);					//add the page to disk block
		//remove the page from the page frame index =0
		cout << "\nSWAP OUT COMPLETE FOR page address " << (*(pt + pageframeindex))->address;
		++NUMBER_SWAPOUTS;
	}
	void Swap_In(PageTable_entry* pt, DiskBlock in_disk)
	{
		//move a page from disk into first spot page frame array for random replacement
		MEM_CYCLES += SWAP_COST;
		pt->Presentbit = 1;					//set pagetable present bit to true
		pt->Dirtybit = 0;					//set modify bit to false;
		if (in_disk.Remove_disk(pt->address))	//remove disk block with page
			cout << "\nPage with address " << pt->address << "successfully removed ";
		else
			cout << "\n ****ERROR***** \nPage with address " << pt->address << "unsuccessfully removed \n";


	}
	//these will call main memory do to everything
	void read(int address)
	{
		++MEM_ACCESS;



	}
	void write(int address)
	{
		++MEM_ACCESS;
	}
};

//Write Function
//set modify bit 
//possibly write to disk
//possible page replacement


void Read_Input_file(string filename) {
	string myText;						// myText is used to read lines from the file with stringstream
	string first_line;
	string character;
	int address1;
	int address2;
	int page_frames;

	Main_Memory mem;
	PageTable* PD_array;
	PD_array = new PageTable[1024];
	
	
	ofstream debugfile, tracefile;
	debugfile.open("debug.txt");
	debugfile << "*****Debug file*******";
	tracefile.open("trace.txt");
	tracefile << "*****Trace file*******";

	// Read from the text file
	ifstream MyReadFile(filename.c_str());

	getline(MyReadFile, first_line);
	istringstream istr1(first_line);
	//read the first line containg number of page fraems : ex)p 9
	istr1 >> character;
	if (character[0] == 'p' || character[0] == 'P')
	{
		istr1 >> page_frames;
		debugfile << "\nRead in the number of max number of user page frames: " << character[0] << " " << page_frames;
		NUMBER_PAGE_FRAMES = (page_frames > 0) ? page_frames : 1; //if number of page frames is less than 0 use 1 page frame
	}

	// Use a while loop together with the getline() function to read the file line by line
	while (getline(MyReadFile, myText)) {
		// Output the text from the file
		debugfile << "\n Read from file: " << myText << " End of line \n";
		istringstream istr1(myText);

		for (int i = 0; i < 5; ++i)
		{
			istr1 >> character;

			if (character[0] == 'w' || character[0] == 'W')	//check for write 
			{
				debugfile << "\nWrite operation: " << character[0];
				istr1 >> address1 >> address2;
				debugfile << "\naddress1 " << address1 << "\naddress2 " << address2;
				int page_offset = get_page_offset(address1);
				int page_table_index = get_pagetable_index(address1);
				int page_dir_index = get_pagedir_index(address1);
				debugfile << "\npage_offset " << page_offset;
				debugfile << "\npage_table_index " << page_table_index;
				debugfile << "\npage_dir_index " << page_dir_index;
				//call a write function
				++MEM_ACCESS;
			}
			else if (character[0] == 'r' || character[0] == 'R')
			{
				++MEM_ACCESS;		//read is a memory access
				debugfile << "\nRead operation: " << character[0];
				istr1 >> address1;
				debugfile << "\naddress1 " << address1;
				int page_offset = get_page_offset(address1);
				int page_table_index = get_pagetable_index(address1);
				int page_dir_index = get_pagedir_index(address1);
				debugfile << "\npage_offset " << page_offset;
				debugfile << "\npage_table_index " << page_table_index;
				debugfile << "\npage_dir_index " << page_dir_index;
									
				if ((PD_array[page_dir_index]).exists == 0)				//no page directory entry exists for this index
				{ 
					debugfile << "\n page Fault occured at pd["<< page_dir_index <<"]";
					tracefile << "\nPD[" << page_dir_index << "] is NULL: 1 cycle";
					++MEM_CYCLES;
					PD_array[page_dir_index].exists = 1;		//make a page table entry associated with this page directory index
					MEM_CYCLES += SWAP_COST;
					cout << "\nPD[" << page_dir_index << "] allocates new page table: 5000 cycles -- start output 1 read";
					++MEM_CYCLES;
					cout << "\nPD[" << page_dir_index << "] = address of page table[" << page_dir_index << "], 1 cycle ";
					++NUM_PAGES_PAGETABLE;
					cout << "\nNew page table allocated Pagetable[" << page_dir_index << "]";
					if (PD_array[page_dir_index].pt_entries[page_table_index].Presentbit == 0)	//if there is no page on the page table index
					{
						MEM_CYCLES += REPLACEMENT_CYCLES;
						cout << "\nPT[" << page_table_index << "] is NULL: 10 cycles";
						MEM_CYCLES += SWAP_COST;
						cout << "\nPT[" << page_table_index << "] allocates new page : 5000 cycles";
						PD_array[page_dir_index].pt_entries[page_table_index].address = get_address(page_table_index, page_dir_index);
						MEM_CYCLES += REPLACEMENT_CYCLES;
						cout << "\nPT[" << page_table_index << "] is address "<< PD_array[page_dir_index].pt_entries[page_table_index].address <<", 10 cycles";
						cout << "\nR address + " << page_offset << " ,10 cycles";
						PageTable_entry* temp_ptr = &(PD_array[page_dir_index].pt_entries[page_table_index]);
						mem.allocate_free_frames(temp_ptr);
						cout << "\n After Change address " << PD_array[page_dir_index].pt_entries[page_table_index].address;
						//make a page frame with this
						//set the page as present
						//set page frame index
					}
					else													//page is currently in memory and has page frame
					{
						MEM_CYCLES += REPLACEMENT_CYCLES ;
						PD_array[page_dir_index].pt_entries[page_table_index].address = get_address(page_table_index, page_dir_index);
						cout << "\nPT[" << page_table_index << "] is address " << PD_array[page_dir_index].pt_entries[page_table_index].address << ", 10 cycles";
						MEM_CYCLES += REPLACEMENT_CYCLES;
						cout << "\nR address + " << page_offset << " ,10 cycles";
						//INCREASE MEM_ACCESS
					}

				}
				else
				{
					cout << "\nPD[ " << page_dir_index << "] is address , 1 cycle";
					++MEM_CYCLES;
				}
			
			}
			else {
				debugfile << "Unknown variable read!Exiting file";
				cout << "Unknown variable read!Exiting file";
				break;
			}
		}
	}

	// Close the file
	MyReadFile.close();
	debugfile.close();
	tracefile.close();
}

int main()
{
	Read_Input_file("input2.txt");
	//PageDirectory_entry* PageDir[MAX_PAGE_ENTRIES];
	//PageTable pt_array[1024];
	//sample PageDir[0].page_table=pt_array[0]	//example address called for dir index 0 which corresponds page table 0
	// get the ptarray[0].pt_entries[index]
	//ptarray[0].pt_entries[index].address gets the address of the page we can then mess with
	//create a page with the address then do things with the page
	


	STATS stat_file;
	stat_file.write_to_output();

}

// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu


