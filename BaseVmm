//this has the functionality to read the file and create the base output
// CSC139HW2.cpp : This file contains the 'main' function. Program execution begins and ends there.
//Sharon Fitzpatrick
// VMM Simulator

#include<cstdio>  
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<stack>
#include<string>
#include<iostream>
#include <fstream>
#include <sstream> 

using namespace std;


#define REPLACEMENT_CYCLES = 10;   
#define PAGE_SIZE = 4096;							//
#define PAGE_DIR_ACCESS =1;							// access through PD cost 1 cycle each

//global variables
int MEM_CYCLES=0;
int MEM_ACCESS=0;
int NUMBER_SWAPINS=0;
int NUMBER_SWAPOUTS=0;
int TOTAL_PAGES_MALLOC=0;
int TRIPLES=0;
int NUMBER_PAGE_FRAMES=0;
int NUM_PAGES_PAGETABLE=0;
int LAST_WORKING_SET=0;
int MAX_WORKING_SET=0;
int MAX_PHYSICAL_PAGES=0;
int MEM_CYCLES_NO_VMM=0;


class STATS {
public:
	
	/*STATS()
	{
		MEM_CYCLES = 0;
		MEM_CYCLES_NO_VMM = 0;
		MEM_ACCESS = 0;
		NUMBER_SWAPINS = 0;
		NUMBER_SWAPOUTS = 0;
		TOTAL_PAGES_MALLOC = 0;
		TRIPLES = 0;
		LAST_WORKING_SET = 0;
		MAX_WORKING_SET =0;
		MAX_PHYSICAL_PAGES =0;
		NUMBER_PAGE_FRAMES = 0;
		NUM_PAGES_PAGETABLE = 0;
	}*/
	void write_to_output()
	{
		ofstream myfile;
		myfile.open("output.txt");
		myfile << "***Paging Activity Statistics * **.\n";
		myfile << "number of memory accesses ="<< MEM_ACCESS<<" .\n";
		myfile << "number of triples(1 + access) = " << TRIPLES << " .\n";
		myfile << "number of swap ins(faults) = " << NUMBER_SWAPINS << " .\n";
		myfile << "number of swap outs = " << NUMBER_SWAPOUTS << " .\n";
		myfile << "total number of pages malloced = " << TOTAL_PAGES_MALLOC << " .\n";
		myfile << "number of pages for Page Tables = " << NUM_PAGES_PAGETABLE << " .\n";
		myfile << "number of page frames for user = " << NUMBER_PAGE_FRAMES << " .\n";
		myfile << "total memory cycles = " << MEM_CYCLES << " .\n";
		myfile << "cycles w / o Vmm = " << MEM_CYCLES_NO_VMM << " .\n";
		myfile << "cycles per swap_in = 5000.\n";
		myfile << "cycles per swap_out = 5000.\n";
		myfile << "last working set size = " << LAST_WORKING_SET << " .\n";
		myfile << "max working set size ever = " << MAX_WORKING_SET << " .\n";
		myfile << "max physical pages = " << MAX_PHYSICAL_PAGES << " .\n";
		myfile << "page size = 4096.\n";
		myfile << "replacement algorithm = random.\n";
		myfile.close();
	}

};
//function to read file
void Read_Input_file(string filename) {
	string myText;						// myText is used to read lines from the file with stringstream
	string first_line;
	string character;
	int address1;
	int address2;
	int page_frames;

	// Read from the text file
	ifstream MyReadFile(filename.c_str());

	getline(MyReadFile, first_line);
	istringstream istr1(first_line);
	//read the first line containg number of page fraems : ex)p 9
	istr1 >> character;
	if (character[0] == 'p' || character[0] == 'P')
	{
		istr1 >> page_frames;
		cout << "\nRead in the number of max number of user page frames: " << character[0] << " " << page_frames;
		NUMBER_PAGE_FRAMES = (page_frames > 0) ? page_frames : 1; //if number of page frames is less than 0 use 1 page frame
	}

	// Use a while loop together with the getline() function to read the file line by line
	while (getline(MyReadFile, myText)) {
		// Output the text from the file
		cout << "\n Read from file: " << myText << " End of line \n";
		istringstream istr1(myText);

		for (int i = 0; i < 5; ++i)
		{
			istr1 >> character;

			if (character[0] == 'w' || character[0] == 'W')
			{
				cout << "\nWrite operation: " << character[0];
				istr1 >> address1 >> address2;
				cout << "\naddress1 " << address1 << "\naddress2 " << address2;
			}
			else if (character[0] == 'r' || character[0] == 'R')
			{
				cout << "\nRead operation: " << character[0];
				istr1 >> address1;
				cout << "\naddress1 " << address1;
			}
			else {
				cout << "Unknown variable read!Exiting file";
				break;
			}
		}
	}

	// Close the file
	MyReadFile.close();
}


//function to check for swap out

//function for the disk block

//Page Table

//Page Directory


int main()
{

	Read_Input_file("input.txt");

	STATS stat_file;
	stat_file.write_to_output();

}

// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu


